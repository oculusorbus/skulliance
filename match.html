<!DOCTYPE html>
<html>
<head>
    <title>Match-3 Game with Chained Bomb Animations</title>
    <style>
        #game-board {
            display: grid;
            gap: 2px;
            background: #333;
            padding: 10px;
            width: fit-content;
            user-select: none;
            position: relative;
        }
        .tile {
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            cursor: pointer;
            transition: transform 0.2s ease;
            position: relative;
            background: #444;
        }
        .tile img {
            width: 40px;
            height: 40px;
            object-fit: contain;
            position: absolute;
            z-index: 1;
        }
        .tile::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.6;
            z-index: 0;
        }
        .selected {
            transform: scale(1.1);
            border: 2px solid white;
            z-index: 2;
            pointer-events: none;
        }
        .matched {
            animation: matchAnimation 0.3s ease forwards;
        }
        .falling {
            transition: transform 0.3s ease-out;
        }
        .bomb-creation {
            animation: bombPopIn 0.5s ease forwards;
        }
        .carbon-clear {
            animation: carbonSweep 0.8s ease forwards;
        }
        .diamond-clear {
            animation: diamondShockwave 1s ease forwards;
        }
        #score {
            font-size: 24px;
            margin: 10px;
            font-family: Arial;
            color: #fff;
        }
        @keyframes matchAnimation {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.8; }
            100% { transform: scale(0); opacity: 0; }
        }
        @keyframes bombPopIn {
            0% { transform: scale(0); opacity: 0; }
            70% { transform: scale(1.2); opacity: 1; }
            100% { transform: scale(1); opacity: 1; }
        }
        @keyframes carbonSweep {
            0% { transform: scale(1); opacity: 1; background-color: #ff6600; box-shadow: 0 0 10px #ff3300; }
            50% { transform: scale(1.2); opacity: 0.8; background-color: #ff9900; box-shadow: 0 0 20px #ff6600; }
            100% { transform: scale(0); opacity: 0; background-color: #ffcc00; box-shadow: 0 0 30px #ff9900; }
        }
        @keyframes diamondShockwave {
            0% { transform: scale(1); opacity: 1; background-color: #ffffff; box-shadow: 0 0 0 #ff00ff; }
            50% { transform: scale(1.5); opacity: 0.8; background-color: #ff00ff; box-shadow: 0 0 20px #ff00ff; }
            75% { transform: scale(1); opacity: 0.5; background-color: #9900cc; box-shadow: 0 0 40px #ff00ff; }
            100% { transform: scale(0); opacity: 0; background-color: #000000; box-shadow: 0 0 60px #ff00ff; }
        }
        body {
            background: #0F0F0F;
        }
    </style>
</head>
<body>
    <div id="score">Score: 0</div>
    <div id="game-board"></div>

    <script>
class Match3Game {
    constructor(width, height) {
        this.width = width;
        this.height = height;
        this.board = [];
        this.selectedTile = null;
        this.score = 0;
        this.allIcons = [
            'https://www.skulliance.io/staking/icons/dark.png',
            'https://www.skulliance.io/staking/icons/maxi.png',
            'https://www.skulliance.io/staking/icons/dank.png',
            'https://www.skulliance.io/staking/icons/mipa.png',
            'https://www.skulliance.io/staking/icons/ustra.png',
            'https://www.skulliance.io/staking/icons/nat.png',
            'https://www.skulliance.io/staking/icons/fire.png',
            'https://www.skulliance.io/staking/icons/eye.png',
            'https://www.skulliance.io/staking/icons/sharon.png',
            'https://www.skulliance.io/staking/icons/lens.png',
            'https://www.skulliance.io/staking/icons/kala.png',
            'https://www.skulliance.io/staking/icons/ass.png',
            'https://www.skulliance.io/staking/icons/moon.png',
            'https://www.skulliance.io/staking/icons/ritual.png',
            'https://www.skulliance.io/staking/icons/wave.png',
            'https://www.skulliance.io/staking/icons/soul.png',
            'https://www.skulliance.io/staking/icons/stag.png',
            'https://www.skulliance.io/staking/icons/skowl.png',
            'https://www.skulliance.io/staking/icons/loot.png',
            'https://www.skulliance.io/staking/icons/venus.png',
            'https://www.skulliance.io/staking/icons/axion.png',
            'https://www.skulliance.io/staking/icons/void.png',
            'https://www.skulliance.io/staking/icons/muse.png',
            'https://www.skulliance.io/staking/icons/dn.png',
            'https://www.skulliance.io/staking/icons/tribe.png',
            'https://www.skulliance.io/staking/icons/star.png',
            'https://www.skulliance.io/staking/icons/dread.png',
            'https://www.skulliance.io/staking/icons/hype.png',
            'https://www.skulliance.io/staking/icons/sinder.png',
            'https://www.skulliance.io/staking/icons/cyber.png',
            'https://www.skulliance.io/staking/icons/crypt.png'
        ];
        this.specialIcons = {
            carbon: 'https://www.skulliance.io/staking/icons/carbon.png',
            diamond: 'https://www.skulliance.io/staking/icons/diamond.png'
        };
        this.colorPalette = [
            '#800000', // Crimson Gore (bold red)
            '#008080', // Toxic Teal (vibrant teal)
            '#408000', // Poison Green (sickly green)
            '#4B0082', // Witch Purple (deep purple)
            '#666633', // Ghoul Gray (murky gray)
            '#804000', // Flesh Rot (bold orange-brown)
            '#004080'  // Spectral Blue (ghostly blue)
        ];
        this.icons = this.selectRandomIcons(7);
        this.iconColorMap = this.createIconColorMap();
        this.specialTypes = { bomb4: 'carbon', bomb5: 'diamond' };
        this.isDragging = false;
        this.matchCheckCount = 0;
        this.targetTile = null;
        this.dragDirection = null;
        this.offsetX = 0;
        this.offsetY = 0;

        this.initBoard();
        this.renderBoard();
        this.addEventListeners();
    }

    selectRandomIcons(count) {
        const shuffled = [...this.allIcons].sort(() => 0.5 - Math.random());
        return shuffled.slice(0, count);
    }

    createIconColorMap() {
        const map = {};
        this.icons.forEach((icon, index) => {
            map[icon] = this.colorPalette[index % this.colorPalette.length];
        });
        map[this.specialIcons.carbon] = '#333300'; // Dark olive for Carbon
        map[this.specialIcons.diamond] = '#000000'; // Black for Diamond
        return map;
    }

    initBoard() {
        this.board = [];
        for (let y = 0; y < this.height; y++) {
            this.board[y] = [];
            for (let x = 0; x < this.width; x++) {
                let tile;
                do {
                    tile = this.createRandomTile();
                } while (
                    (x >= 2 && this.board[y][x-1].icon === tile.icon && this.board[y][x-2].icon === tile.icon) ||
                    (y >= 2 && this.board[y-1][x].icon === tile.icon && this.board[y-2][x].icon === tile.icon)
                );
                this.board[y][x] = tile;
            }
        }
        this.renderBoard();
    }

    createRandomTile() {
        return {
            icon: this.icons[Math.floor(Math.random() * this.icons.length)],
            special: null,
            element: null
        };
    }

    renderBoard() {
        const boardElement = document.getElementById('game-board');
        boardElement.style.gridTemplateColumns = `repeat(${this.width}, 50px)`;
        boardElement.innerHTML = '';

        for (let y = 0; y < this.height; y++) {
            for (let x = 0; x < this.width; x++) {
                const tile = this.board[y][x];
                const tileElement = document.createElement('div');
                tileElement.className = 'tile';
                
                if (tile.special) {
                    const img = document.createElement('img');
                    img.src = this.specialIcons[tile.special];
                    tileElement.appendChild(img);
                    tileElement.style.backgroundColor = this.iconColorMap[this.specialIcons[tile.special]];
                } else if (tile.icon) {
                    const img = document.createElement('img');
                    img.src = tile.icon;
                    tileElement.appendChild(img);
                    tileElement.style.backgroundColor = this.iconColorMap[tile.icon];
                }

                tileElement.dataset.x = x;
                tileElement.dataset.y = y;
                boardElement.appendChild(tileElement);
                tile.element = tileElement;

                if (!this.isDragging || (this.selectedTile && (this.selectedTile.x !== x || this.selectedTile.y !== y))) {
                    tileElement.style.transform = 'translate(0, 0)';
                }
            }
        }
    }

    addEventListeners() {
        const board = document.getElementById('game-board');
        
        board.addEventListener('mousedown', (e) => this.handleMouseDown(e));
        board.addEventListener('mousemove', (e) => this.handleMouseMove(e));
        board.addEventListener('mouseup', (e) => this.handleMouseUp(e));
        
        board.addEventListener('touchstart', (e) => this.handleMouseDown(e));
        board.addEventListener('touchmove', (e) => this.handleMouseMove(e));
        board.addEventListener('touchend', (e) => this.handleMouseUp(e));
    }

    getTileFromEvent(e) {
        const tileElement = e.target.closest('.tile');
        if (!tileElement) return null;
        const x = parseInt(tileElement.dataset.x);
        const y = parseInt(tileElement.dataset.y);
        return { x, y, element: tileElement };
    }

    handleMouseDown(e) {
        e.preventDefault();
        const tile = this.getTileFromEvent(e.touches ? e.touches[0] : e);
        if (!tile || !tile.element) return;

        this.isDragging = true;
        this.selectedTile = { x: tile.x, y: tile.y };
        tile.element.classList.add('selected');

        const boardRect = document.getElementById('game-board').getBoundingClientRect();
        const mouseX = e.touches ? e.touches[0].clientX : e.clientX;
        const mouseY = e.touches ? e.touches[0].clientY : e.clientY;
        this.offsetX = mouseX - (boardRect.left + this.selectedTile.x * 52);
        this.offsetY = mouseY - (boardRect.top + this.selectedTile.y * 52);

        console.log(`Selected tile at (${tile.x}, ${tile.y}), offset: (${this.offsetX}, ${this.offsetY})`);
    }

    handleMouseMove(e) {
        if (!this.isDragging || !this.selectedTile) return;
        e.preventDefault();

        const mouseX = e.touches ? e.touches[0].clientX : e.clientX;
        const mouseY = e.touches ? e.touches[0].clientY : e.clientY;

        const boardRect = document.getElementById('game-board').getBoundingClientRect();
        const tileSizeWithGap = 52;
        const tileX = mouseX - boardRect.left - this.offsetX;
        const tileY = mouseY - boardRect.top - this.offsetY;

        const selectedTileElement = this.board[this.selectedTile.y][this.selectedTile.x].element;
        selectedTileElement.style.transition = '';

        if (!this.dragDirection) {
            const dx = Math.abs(mouseX - (boardRect.left + this.selectedTile.x * tileSizeWithGap + this.offsetX));
            const dy = Math.abs(mouseY - (boardRect.top + this.selectedTile.y * tileSizeWithGap + this.offsetY));
            if (dx > dy && dx > 5) this.dragDirection = 'row';
            else if (dy > dx && dy > 5) this.dragDirection = 'column';
            console.log(`Drag direction set to: ${this.dragDirection}`);
        }

        if (!this.dragDirection) return;

        if (this.dragDirection === 'row') {
            const constrainedX = Math.max(0, Math.min((this.width - 1) * tileSizeWithGap, tileX));
            selectedTileElement.style.transform = `translate(${constrainedX - this.selectedTile.x * tileSizeWithGap}px, 0) scale(1.1)`;
            this.targetTile = {
                x: Math.round(constrainedX / tileSizeWithGap),
                y: this.selectedTile.y
            };
        } else if (this.dragDirection === 'column') {
            const constrainedY = Math.max(0, Math.min((this.height - 1) * tileSizeWithGap, tileY));
            selectedTileElement.style.transform = `translate(0, ${constrainedY - this.selectedTile.y * tileSizeWithGap}px) scale(1.1)`;
            this.targetTile = {
                x: this.selectedTile.x,
                y: Math.round(constrainedY / tileSizeWithGap)
            };
        }

        console.log(`Dragging to (${this.targetTile.x}, ${this.targetTile.y})`);
    }

    handleMouseUp(e) {
        if (!this.isDragging || !this.selectedTile || !this.targetTile) {
            if (this.selectedTile) {
                const tile = this.board[this.selectedTile.y][this.selectedTile.x];
                if (tile.element) tile.element.classList.remove('selected');
            }
            this.isDragging = false;
            this.selectedTile = null;
            this.targetTile = null;
            this.dragDirection = null;
            this.renderBoard();
            console.log('Mouse up, no valid swap');
            return;
        }

        const tile = this.board[this.selectedTile.y][this.selectedTile.x];
        if (tile.element) tile.element.classList.remove('selected');

        console.log(`Mouse up, sliding from (${this.selectedTile.x}, ${this.selectedTile.y}) to (${this.targetTile.x}, ${this.targetTile.y})`);
        this.slideTiles(this.selectedTile.x, this.selectedTile.y, this.targetTile.x, this.targetTile.y);

        this.isDragging = false;
        this.selectedTile = null;
        this.targetTile = null;
        this.dragDirection = null;
    }

    isInSameRowOrColumn(x1, y1, x2, y2) {
        return (y1 === y2) || (x1 === x2);
    }

    slideTiles(startX, startY, endX, endY) {
        const tileSizeWithGap = 52;
        let tilesToMove = [];
        let direction;

        if (startY === endY) { // Row movement
            direction = startX < endX ? 1 : -1;
            for (let x = startX; x !== endX; x += direction) {
                tilesToMove.push({ x, y: startY });
            }
        } else if (startX === endX) { // Column movement
            direction = startY < endY ? 1 : -1;
            for (let y = startY; y !== endY; y += direction) {
                tilesToMove.push({ x: startX, y });
            }
        }

        const selectedTile = this.board[startY][startX];
        const selectedElement = selectedTile.element;
        const dx = (endX - startX) * tileSizeWithGap;
        const dy = (endY - startY) * tileSizeWithGap;

        selectedElement.style.transition = 'transform 0.2s ease';
        selectedElement.style.transform = `translate(${dx}px, ${dy}px)`;

        tilesToMove.forEach(({ x, y }) => {
            const tile = this.board[y][x];
            const offsetX = direction * (startX === endX ? 0 : -tileSizeWithGap);
            const offsetY = direction * (startY === endY ? 0 : -tileSizeWithGap);
            tile.element.style.transition = 'transform 0.2s ease';
            tile.element.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
        });

        setTimeout(() => {
            if (startY === endY) {
                const row = this.board[startY];
                if (startX < endX) {
                    for (let x = startX; x < endX; x++) {
                        row[x] = row[x + 1];
                    }
                } else {
                    for (let x = startX; x > endX; x--) {
                        row[x] = row[x - 1];
                    }
                }
                row[endX] = selectedTile;
            } else {
                if (startY < endY) {
                    for (let y = startY; y < endY; y++) {
                        this.board[y][startX] = this.board[y + 1][startX];
                    }
                } else {
                    for (let y = startY; y > endY; y--) {
                        this.board[y][startX] = this.board[y - 1][startX];
                    }
                }
                this.board[endY][endX] = selectedTile;
            }

            this.checkMatches();
            this.renderBoard();
        }, 200);
    }

    checkMatches() {
        let hasMatches = false;
        const allMatches = new Set();

        // Horizontal matches
        for (let y = 0; y < this.height; y++) {
            let matchStart = 0;
            let currentIcon = null;
            for (let x = 0; x <= this.width; x++) {
                const tile = x < this.width ? this.board[y][x] : null;
                const icon = tile ? (tile.special ? this.specialIcons[tile.special] : tile.icon) : null;

                if (icon !== currentIcon || x === this.width) {
                    const matchLength = x - matchStart;
                    if (matchLength >= 3) {
                        for (let i = matchStart; i < x; i++) {
                            allMatches.add(`${i},${y}`);
                        }
                        console.log(`Horizontal match of ${matchLength} at row ${y}, start ${matchStart}, end ${x - 1}`);
                        hasMatches = true;
                    }
                    matchStart = x;
                    currentIcon = icon;
                }
            }
        }

        // Vertical matches
        for (let x = 0; x < this.width; x++) {
            let matchStart = 0;
            let currentIcon = null;
            for (let y = 0; y <= this.height; y++) {
                const tile = y < this.height ? this.board[y][x] : null;
                const icon = tile ? (tile.special ? this.specialIcons[tile.special] : tile.icon) : null;

                if (icon !== currentIcon || y === this.height) {
                    const matchLength = y - matchStart;
                    if (matchLength >= 3) {
                        for (let i = matchStart; i < y; i++) {
                            allMatches.add(`${x},${i}`);
                        }
                        console.log(`Vertical match of ${matchLength} at col ${x}, start ${matchStart}, end ${y - 1}`);
                        hasMatches = true;
                    }
                    matchStart = y;
                    currentIcon = icon;
                }
            }
        }

        if (hasMatches) {
            const matchSize = allMatches.size;
            const lastMatch = Array.from(allMatches).pop();
            const [bombX, bombY] = lastMatch.split(',').map(Number);
            console.log(`Total unique matched tiles: ${matchSize}, last position: (${bombX}, ${bombY})`);

            if (allMatches.size >= 3) {
                const firstTile = this.board[bombY][bombX];
                if (firstTile && firstTile.special) {
                    this.handleBombMatches(allMatches, firstTile.special, bombX, bombY);
                } else {
                    this.handleMatches(allMatches, matchSize === 4 ? 'bomb4' : matchSize >= 5 ? 'bomb5' : null, bombX, bombY);
                }
            }
        }

        return hasMatches;
    }

    handleMatches(matches, bombType, bombX, bombY) {
        matches.forEach(match => {
            const [x, y] = match.split(',').map(Number);
            if (this.board[y][x].element) {
                this.board[y][x].element.classList.add('matched');
            }
        });

        setTimeout(() => {
            matches.forEach(match => {
                const [x, y] = match.split(',').map(Number);
                this.board[y][x].icon = null;
                this.board[y][x].special = null;
                this.board[y][x].element = null;
            });

            if (bombType) {
                this.createSpecialTile(bombX, bombY, bombType);
                this.board[bombY][bombX].element.classList.add('bomb-creation');
            }

            this.score += matches.size * 10;
            document.getElementById('score').textContent = `Score: ${this.score}`;
            
            this.cascadeTiles();
        }, 300);
    }

    handleBombMatches(matches, bombType, bombX, bombY) {
        matches.forEach(match => {
            const [x, y] = match.split(',').map(Number);
            if (this.board[y][x].element) {
                this.board[y][x].element.classList.add('matched');
            }
        });

        setTimeout(() => {
            matches.forEach(match => {
                const [x, y] = match.split(',').map(Number);
                this.board[y][x].icon = null;
                this.board[y][x].special = null;
                this.board[y][x].element = null;
            });

            if (bombType === 'carbon') {
                this.clearRowAndColumn(bombX, bombY);
            } else if (bombType === 'diamond') {
                this.clearBoard();
            }

            this.score += matches.size * 10;
            document.getElementById('score').textContent = `Score: ${this.score}`;
            
            // Cascade will be called by clearRowAndColumn or clearBoard
        }, 300);
    }

    clearRowAndColumn(x, y) {
        console.log(`Clearing row ${y} and column ${x} (Carbon Bomb)`);
        const affectedTiles = new Set();
        const diamondPositions = [];

        // Collect tiles to animate and check for Diamond bombs
        for (let i = 0; i < this.width; i++) {
            if (this.board[y][i].element) {
                affectedTiles.add(this.board[y][i].element);
                if (this.board[y][i].special === 'diamond') {
                    diamondPositions.push({ x: i, y: y });
                }
            }
        }
        for (let j = 0; j < this.height; j++) {
            if (this.board[j][x].element) {
                affectedTiles.add(this.board[j][x].element);
                if (this.board[j][x].special === 'diamond') {
                    diamondPositions.push({ x: x, y: j });
                }
            }
        }

        // Apply Carbon animation
        affectedTiles.forEach(tileElement => {
            tileElement.classList.add('carbon-clear');
        });

        // After Carbon animation, clear and check for Diamond chain
        setTimeout(() => {
            for (let i = 0; i < this.width; i++) {
                this.board[y][i].icon = null;
                this.board[y][i].special = null;
                this.board[y][i].element = null;
            }
            for (let j = 0; j < this.height; j++) {
                this.board[j][x].icon = null;
                this.board[j][x].special = null;
                this.board[j][x].element = null;
            }
            this.renderBoard();

            if (diamondPositions.length > 0) {
                console.log(`Diamond bomb(s) detected in Carbon explosion at: ${JSON.stringify(diamondPositions)}`);
                setTimeout(() => {
                    this.clearBoard(); // Chain Diamond board clear
                }, 200); // Small delay for visual separation
            } else {
                this.cascadeTiles(); // No Diamond, just cascade
            }
        }, 800); // Match carbonSweep duration
    }

    clearBoard() {
        console.log('Clearing entire board (Diamond Bomb)');
        const affectedTiles = new Set();

        for (let y = 0; y < this.height; y++) {
            for (let x = 0; x < this.width; x++) {
                if (this.board[y][x].element) {
                    affectedTiles.add(this.board[y][x].element);
                }
            }
        }

        affectedTiles.forEach(tileElement => {
            tileElement.classList.add('diamond-clear');
        });

        setTimeout(() => {
            for (let y = 0; y < this.height; y++) {
                for (let x = 0; x < this.width; x++) {
                    this.board[y][x].icon = null;
                    this.board[y][x].special = null;
                    this.board[y][x].element = null;
                }
            }
            this.renderBoard();
            this.cascadeTiles();
        }, 1000); // Match diamondShockwave duration
    }

    createSpecialTile(x, y, type) {
        this.board[y][x] = {
            icon: null,
            special: this.specialTypes[type],
            element: null
        };
        console.log(`Created ${this.specialTypes[type]} bomb at (${x}, ${y})`);
        this.renderBoard();
    }

    cascadeTiles() {
        for (let x = 0; x < this.width; x++) {
            let emptySpaces = 0;
            for (let y = this.height - 1; y >= 0; y--) {
                if (!this.board[y][x].icon && !this.board[y][x].special) {
                    emptySpaces++;
                } else if (emptySpaces > 0) {
                    this.board[y + emptySpaces][x] = this.board[y][x];
                    this.board[y][x] = { icon: null, special: null, element: null };
                }
            }
            for (let i = 0; i < emptySpaces; i++) {
                this.board[i][x] = this.createRandomTile();
            }
        }
        this.renderBoard();
        setTimeout(() => this.checkMatches(), 300);
    }
}

const game = new Match3Game(8, 8);
    </script>
</body>
</html>